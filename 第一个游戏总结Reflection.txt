v1.0总结

不是贪吃蛇五子棋这种，可能大家没见过， 
http://tieba.baidu.com/p/1796671242
这个帖子是这个游戏的规则。

我用c和easyx的graphic库在vc上做的，下面是exe文件，有2个大bug，就是鼠标和按键顺序混乱，因为kbhit()和getch()我查到是不读取缓冲区的，但实际上就是先按键再用这两个函数却立马就有效，我实在是没办法了。还有一个是根据游戏规则，隔板是不能把棋子封闭起来的，但我不会做判断是否封闭的功能，即使硬着头皮做也太费时间。
http://pan.baidu.com/share/link?shareid=2659&uk=3758190990

这个程序花了我整整4天啊！！各种无头绪，各种纠结，各种大范围修改，各种调试半天，各种不会立马学，各种查资料借鉴提问。其实我是想做这个程序才学c语言的。。。之前刚把XX的书（我知道你们又要骂了）看完，只编了些判断闰年，小动画，排序之类的小程序，就立马做这个大的，至少对我来说是个挑战，也确实，没基础很蛋疼，有点眼高手低了。

整个过程基本是爬过来的，一点一点实现，经常发现某个功能加不进去了，只能修改整个程序内核，改了无数次。整天按着机器思维想，“如果。。。就。。。否则。。。再循环，”，“这串代码放循环里面还是外面呢？”等等。我算是体会到什么叫结构了，框架真的很重要，我现在一点点来，没有全局观，后来都是牵一发动全身，经常加了一个功能，却发现相关的函数有很微妙的地方不匹配，然后单步调试了半天。

虽然我花了很多时间简化代码，也已经经历做到最好了，但是整个代码我还是感觉编得很复杂，用了n多的选择和循环，套来套去头晕死了，可能是核心思想有问题，不知道还有多少简化空间，或者能不能换个更好的内核和实现方式，但我已经在我水平之内尽力了，

真没想到我一下能编600+行的程序，估计是新手大惊小怪吧，不过这次学到很多很多，用了数组，结构体，指针，这些一开始都没想到要用，后来发现不得不用。总的来说，这个程序我做得很累，不过乐在其中，给外行看肯定是太烂了，不过正接触过编程的人都知道不容易啊。。。

源码我暂时不传到硬盘，因为还有很大的bug，而且很乱，虽然我做了大量详细的注释，不过应该还是不容易看懂。我会继续改善这个游戏，希望愿意真心给我建议的高手留个邮箱或QQ，具体交流，我真的迫切想要一些思路上的建议，具体语言方面我可以查，但思路上我真的自己无能为力啊



我一开始也是这么想的，后来发现远没有想象的简单。我用鼠标判断是放砖还是走棋，然后用键盘移动棋子和砖，混合起来很麻烦，我觉得用鼠标控制板砖更麻烦。还要判断是否能移动，还要自动跳跃，还有4个player。。。

待改善功能：
1 优化程序结构和判断内核，2 改善画面质量，3 解决先按键盘再点鼠标直接移动的bug，4 可以随时切换移动隔板或棋子，5，人机对战 6，悔棋，7 鼠标控制棋子和隔板（隔板跟随鼠标移动），9 检测是否隔板封闭了棋子，10，联网对战 

问题：
kbhit 和getch 到底什么原理？为什么我的程序里就会出行类似有输入缓冲区的情况。。。
如何动态调整initgraph创建的窗口大小？
graphic做控制台图形编程，没有控件，输出文字图片坐标要算半天，还要调整颜色样式范围，移动部分图片还要用覆盖法，有没有更高效的方法？


v1.1总结：
几个bug都是灵光一现后想到的解决方法，添加悔棋和重新开始功能在主函数的结构上费了不少力气，添加了一些标志性的全局变量，各种代码的顺序很费脑经，不少问题都出在顺序上，还有标志性全局变量在何处初始化显得比较零散，没有模块化的感觉。虽然功能实现了，但结构不好。


v1.2总结
缩放窗口大小，xasp的问题比较麻烦，鼠标位置的判断都要*xasp，其他画图则不需要。顺便巩固了下文件的知识。

封闭检测费相当于重新做一个程序了，太伤脑经了。先是自己想到走迷宫但无法区分2中特殊情况，然后和宋亦祺讨论了2、3天，他给了我很多的思路，比如查隔板，线性规划，没一格分十多种情况讨论，顺逆循环查找，向上优先模式。这些最终启发我想到了把走迷宫和向上优先结合的方法，但是在判断封闭上有一些bug不好处理，最后我终于回想起之前尝试过的记录走迷宫循环最高点的方法解决问题。具体见于宋亦祺的讨论记录和判断封闭函数说明。


v1.3总结
先分了模块，了解了头文件防止重定义以及变量、函数声明的一般方式和规范，还有多cpp工程的一般结构。

然后学习了多线程，开始纠结多线程互相通知的方法，最后使用标志性全局变量控制，大幅改动了主回合函数。


v1.4总结
开始学习网络编程，winsock。深刻感受到基础知识和程序全局观的重要性。网络编程大量牵涉操作系统和硬件，各种函数使用方法也有很多要注意的地方，有时为了理解一个原理要查很久的资料才能找到答案，这也使我开始抱怨自学。

winsock，先理解初始化，绑定，监听，连接和发送接收的过程，然后理解TCP/流式和UDP/数据报，前者要连接，稳定速度慢，能用广域网，后者有广播，多播，组播，速度快但容易丢失数据，只能局域网，因此就没多研究。

然后是理解五种I/O模型，很复杂，同步异步，阻塞非阻塞的概念纠结了一天，后来总算看到一个帖子，慢慢理解了。等我把select，WSAAsycSelect, WSAEventSelect, Overlapped I/O(Completion Routine)和Overlapped I/O(Event)都大致理解之后(completion ports只能在windows 2000和windows NT上运行，所以不学了)，才发现同步异步，阻塞非阻塞不只是在网络编程领域，而是和多线程，同步异步函数，内核对象，CPU等等只是融合在一起的。

我是这样理解的：
普通阻塞模式就是一个socket死等着接受或发送，别的socket只能等这个完成。
select则可以几个socket一起排队，只要有一个能收或发了，就挑选出来，但是每次都要清空队列，再添加，再判断是否在队列中，很耗CPU，效率不高。

异步选择和事件选择都是给socket一种提醒使用者的方式，前者是windows消息机制，后者是事件机制，然后用waitformultievent等函数等着socket通知，实际上还是等着，不过比select效率高，操作少。

事件通知重叠I/O则是用WSArecv等函数直接提交一个recv的要求，由于有重叠结构，可以开辟多个发送接收缓冲区，所以可以重叠I/O。但是为了知道什么时候收到或发完了，就要把socket和event绑定，然后用waitformultievent等待多个socket的完成消息，然后再执行接下来的操作。

完成例程重叠I/O同样是用WSArecv等函数直接提交一个recv的要求，并且用到了回调函数来处理完成例程，然后在完成例程的函数中循环使用WSArecv，这样只要为每个socket启动一个WSArecv，然后就能自动循环了，接收到或发送后的操作都在完成例程里自动执行完了。（但是回调的原理我还没有弄清楚。）

总的来看，要实现异步的I/O，实际上还都是要开多线程，只不过三种选择结构是自己开线程，两种重叠I/O是系统自动开线程。（具体重叠I/O效率高在哪里，我还没有弄懂。）然后就是线程间的通知方式，消息，事件，回调，变量，都可以。所以五种模型只不过是把不同的等待收发方式，开线程方式和不同的通知方式不同地结合下而已。

回调原理的问题：
比如，在一个线程里先把函数b的地址作为函数a的参数，函数a是一个异步函数，所以线程继续执行下面的代码。
我看到网上说函数b一定要在调用函数a的线程处于可警告的等待状态(比如用SleepEx（）)才能回调，是这样吗？如果是这样，那么在sleep时发现函数b可以回调了，此时线程能继续执行sleepex之后的代码吗？还是等回调的函数b执行完再继续？
我本来对这个也不了解，已经尽力表达清楚了，如果看不明白问题再问我，我再根据情况阐述下。

重叠I/O效率高的原因？

研究了一下getch和getchar的原理，两者都是从缓冲区拿走一个字符。
getchar运行时把光标后的内容都打印出来直到'r'，用户输入后按回车，会在末尾加上'\r''\n'，如果打印'\r'（回车符）的话是没有反应的。如果光标后有回车，则直接读取光标后一个字符。
getch运行时判断

总的来说，纯c语言和windows的vc++编译环境导致实用性程序的源码不多，学习时大量碰到MFC的c++和win API代码，看不懂只能放弃。